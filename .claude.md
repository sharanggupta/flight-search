# Flight Search Project - Claude Code Guidelines

## Project Overview
This is a Spring Boot application for flight search functionality. The project uses:
- Spring Boot 3.4.0
- Java 21 (LTS)
- Maven
- PostgreSQL Database
- Lombok for boilerplate reduction
- Spring Data JPA
- Spring Web (REST APIs)
- TestContainers for E2E testing
- WebTestClient for E2E HTTP calls

## Architecture
**True Hexagonal Architecture (Ports and Adapters Pattern)**

This project follows **strict hexagonal architecture** with clear separation between the hexagon (inside) and infrastructure (outside):

### The Hexagon vs Outside

**The Golden Rule**: The hexagon NEVER depends on the outside at compile time.

- **Inside the Hexagon**: Domain + Application layers (pure business logic, NO Spring dependencies)
- **Outside the Hexagon**: Infrastructure layer (ALL framework code - Spring, JPA, REST, etc.)

### Package Structure

```
src/main/java/dev/sharanggupta/flightsearch/
‚îú‚îÄ‚îÄ domain/                           # INSIDE HEXAGON - Pure business entities
‚îÇ   ‚îî‚îÄ‚îÄ Flight.java                  # Domain model - NO framework dependencies
‚îÇ
‚îú‚îÄ‚îÄ application/                      # INSIDE HEXAGON - Application layer
‚îÇ   ‚îú‚îÄ‚îÄ ports/                       # Port interfaces (boundaries)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/                   # Driving ports (use cases)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SearchFlightsUseCase.java    # What the hexagon PROVIDES
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/                  # Driven ports (dependencies)
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ FlightRepository.java        # What the hexagon NEEDS
‚îÇ   ‚îî‚îÄ‚îÄ services/                    # Use case implementations (NO @Service!)
‚îÇ       ‚îî‚îÄ‚îÄ SearchFlightsService.java        # Pure Java - no Spring annotations
‚îÇ
‚îî‚îÄ‚îÄ infrastructure/                   # OUTSIDE HEXAGON - Infrastructure layer
    ‚îú‚îÄ‚îÄ config/                      # Spring wiring
    ‚îÇ   ‚îî‚îÄ‚îÄ ApplicationConfig.java   # @Configuration - wires hexagon at runtime
    ‚îú‚îÄ‚îÄ input/                       # Driving adapters (call the hexagon)
    ‚îÇ   ‚îî‚îÄ‚îÄ rest/
    ‚îÇ       ‚îú‚îÄ‚îÄ FlightController.java        # @RestController - calls use case
    ‚îÇ       ‚îî‚îÄ‚îÄ FlightResponse.java          # HTTP response DTO
    ‚îî‚îÄ‚îÄ output/                      # Driven adapters (implement driven ports)
        ‚îî‚îÄ‚îÄ persistence/
            ‚îú‚îÄ‚îÄ FlightEntity.java            # @Entity - JPA entity
            ‚îú‚îÄ‚îÄ JpaFlightRepository.java     # Spring Data JPA interface
            ‚îî‚îÄ‚îÄ FlightRepositoryAdapter.java # @Component - implements FlightRepository
```

### Key Concepts (from Stack Overflow hexagonal architecture answer)

**1. Naming Confusion:**
- **Hexagonal Architecture** calls the inside part "the application"
- **DDD** has an "application layer" inside the hexagon
- In this project: Domain + Application = The Hexagon

**2. Ports & Adapters:**

**Driving Ports (Input Ports):**
- Interfaces defining what the hexagon OFFERS to the outside
- Location: `application/ports/input/`
- Example: `SearchFlightsUseCase` interface
- Implemented by: Use case classes in `application/services/`

**Driving Adapters (Input Adapters):**
- DON'T implement driving ports, they CALL them
- Location: `infrastructure/input/`
- Example: REST controller calls `SearchFlightsUseCase.searchByOrigin()`

**Driven Ports (Output Ports):**
- Interfaces defining what the hexagon NEEDS from the outside
- Location: `application/ports/output/`
- Example: `FlightRepository` interface
- Defined in terms of domain concepts, technology-agnostic

**Driven Adapters (Output Adapters):**
- DO implement driven ports
- Location: `infrastructure/output/`
- Example: `FlightRepositoryAdapter implements FlightRepository`

**3. Dependency Direction:**
```
Outside ‚Üí Inside (allowed)
Infrastructure ‚Üí Application/Domain (allowed)

Inside ‚Üí Outside (FORBIDDEN at compile time)
Application/Domain ‚Üí Infrastructure (FORBIDDEN)
```

**4. Configuration:**
- Use case implementations CANNOT have `@Service` (framework dependency!)
- Infrastructure layer wires everything at runtime
- `ApplicationConfig` with `@Bean` methods is how Spring creates and injects dependencies

### Architecture Principles:

1. **The hexagon is framework-agnostic**
   - Domain and application layers: Pure Java, NO Spring annotations
   - Can be tested without Spring
   - No compile-time dependency on infrastructure

2. **Ports define contracts**
   - Driving ports (input): What the hexagon provides to the outside
   - Driven ports (output): What the hexagon needs from the outside
   - Both are inside the hexagon (application layer)

3. **Infrastructure knows about the framework**
   - Driving adapters: REST controllers call use cases (with @RestController)
   - Driven adapters: JPA implementations implement ports (with @Component, @Entity)
   - Configuration: Wires everything together with @Configuration and @Bean

4. **Dependency injection happens at runtime**
   - Infrastructure layer injects driven adapters into use cases
   - This is where Spring comes in - but the hexagon doesn't know about Spring!

## Development Workflow

### Double-Loop TDD Practice
**ALWAYS follow this workflow when implementing new features:**

1. **Outer Loop - E2E Test (Red)**
   - Write a failing end-to-end test first
   - E2E test should spin up the full application using TestContainers
   - Make real HTTP calls to the application
   - Run: `./mvnw verify -Dtest=E2E*`

2. **Inner Loop - Unit Tests (Red-Green-Refactor)**
   - Write failing unit tests for the components needed
   - Implement the **simplest possible code** to make tests pass
   - **Including hardcoded return values** - this is intentional and correct
   - Run: `./mvnw test`
   - Refactor while keeping tests green
   - **IMPORTANT: Commit and push immediately when unit tests pass**

3. **Outer Loop - E2E Verification (Green)**
   - Return to E2E test and verify it passes
   - If it fails, add more unit tests and repeat inner loop
   - **Verify feature is truly complete** - ensure service uses repository, not hardcoded data
   - E2E test must seed real test data

4. **Commit and Push**
   - **Commit and push after each passing unit test**
   - **Commit and push when E2E tests pass**
   - Commit message should reflect the feature/behavior added
   - Use conventional commit format with detailed description

### Testing Commands

**Unit Tests Only (all tests except E2E):**
```bash
./mvnw test -Dtest="!E2E*"
```

**E2E Tests Only:**
```bash
./mvnw test -Dtest="E2E*"
```

**All Tests:**
```bash
./mvnw test
```

## Code Style

### Clean Code Principles (Bob Martin)
- **Single Responsibility Principle**: Each class should have one reason to change
- **Open/Closed Principle**: Open for extension, closed for modification
- **Dependency Inversion**: Depend on abstractions, not concretions
- **Small Functions**: Functions should be small and do one thing well
- **Meaningful Names**: Use intention-revealing names
- **Don't Repeat Yourself (DRY)**
- **Boy Scout Rule**: Leave code cleaner than you found it

### Java & Spring Boot Conventions
- Use dependency injection (constructor injection preferred)
- Use Lombok to reduce boilerplate (@Data, @Builder, @AllArgsConstructor, etc.)
- Follow standard Java naming conventions
- Use Optional for potentially null values
- Prefer composition over inheritance
- Use interfaces to define contracts (ports in hexagonal architecture)

### Hexagonal Architecture Guidelines
- **Domain layer (inside hexagon)**: Pure business entities, no framework dependencies
- **Application layer (inside hexagon)**: Ports (interfaces) and use case implementations (pure Java, NO @Service)
- **Infrastructure layer (outside hexagon)**: Framework-specific implementations (Spring config, REST, JPA)
- **Dependency rule**: Infrastructure depends on hexagon, hexagon NEVER depends on infrastructure
- **Configuration**: Use @Bean in infrastructure/config to wire use cases (NO @Service on use cases!)

## Testing Guidelines

### Unit Tests
- Test behavior, not implementation
- Use meaningful test method names (should/when pattern)
- Follow AAA pattern: Arrange, Act, Assert
- Mock external dependencies
- Keep tests fast and isolated
- **TDD: Write simplest code to pass, including hardcoded values**

### E2E Tests
- Use TestContainers to spin up real dependencies
- Make real HTTP calls using RestTemplate or WebTestClient
- Test complete user journeys
- Verify system behavior from outside
- Place in `src/test/java/.../e2e/` package

### Test Naming Conventions
**Unit Tests:**
- Naming: `ClassNameTest.java` (e.g., `SearchFlightsServiceTest.java`, `FlightControllerTest.java`)
- Location: `src/test/java/.../` (mirror main source structure)
- Run with: `./mvnw test -Dtest="!E2E*"`

**E2E Tests:**
- Naming: `E2EFeatureNameTest.java` (e.g., `E2EFlightSearchTest.java`)
- Location: `src/test/java/.../e2e/`
- Run with: `./mvnw test -Dtest="E2E*"`
- Must use `@SpringBootTest` with TestContainers

**Test Methods:**
- Format: `shouldDoSomething_whenCondition()`
- Alternative: `givenCondition_whenAction_thenResult()`
- Examples:
  - `shouldReturnFlightsFromOriginAirport()`
  - `shouldReturn404_whenOriginNotFound()`
  - `givenValidFlight_whenSaving_thenReturnsSavedFlight()`

## Running the Application
```bash
./mvnw spring-boot:run
```

## Building the Application
```bash
./mvnw clean package
```

## Database
- Using H2 in-memory database for development
- H2 Console can be enabled for debugging
- TestContainers for E2E tests with real database

## Git Workflow

### Commit Frequency
- **MUST commit and push after each passing unit test**
- **MUST commit and push when E2E tests pass**
- **MUST commit and push when feature is truly complete**
- Never commit failing tests
- Small, focused commits are better than large ones

### Commit Message Format
```
<type>: <short summary>

<detailed description of what was done and why>

TDD cycle: [Red/Green/Refactor stage]

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

### When to Commit
1. ‚úÖ Unit tests passing (even with hardcoded implementation)
2. ‚úÖ E2E tests passing
3. ‚úÖ Feature complete and verified
4. ‚úÖ Refactoring complete (tests still green)
5. ‚ùå Never commit broken/failing tests

### Push After Every Commit
- Always push immediately after committing
- Keep remote repository in sync
- Command: `git commit -m "..." && git push`

## Future Enhancements
- Add authentication/authorization
- Implement caching
- Add API documentation (Swagger/OpenAPI)
- Add logging and monitoring
- Implement pagination for search results
- Add comprehensive error handling and validation
