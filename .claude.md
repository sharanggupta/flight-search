# Flight Search Project - Claude Code Guidelines

## Project Overview
This is a Spring Boot application for flight search functionality. The project uses:
- Spring Boot 3.4.0
- Java 21 (LTS)
- Maven
- PostgreSQL Database
- Lombok for boilerplate reduction
- Spring Data JPA
- Spring Web (REST APIs)
- TestContainers for E2E testing
- WebTestClient for E2E HTTP calls

## Architecture
**True Hexagonal Architecture (Ports and Adapters Pattern)**

This project follows **strict hexagonal architecture** with clear separation between the hexagon (inside) and infrastructure (outside):

### The Hexagon vs Outside

**The Golden Rule**: The hexagon NEVER depends on the outside at compile time.

- **Inside the Hexagon**: Domain + Application layers (pure business logic, NO Spring dependencies)
- **Outside the Hexagon**: Infrastructure layer (ALL framework code - Spring, JPA, REST, etc.)

### Package Structure

```
src/main/java/dev/sharanggupta/flightsearch/
├── domain/                           # INSIDE HEXAGON - Pure business entities
│   └── Flight.java                  # Domain model - NO framework dependencies
│
├── application/                      # INSIDE HEXAGON - Application layer
│   ├── ports/                       # Port interfaces (boundaries)
│   │   ├── input/                   # Driving ports (use cases)
│   │   │   └── SearchFlightsUseCase.java    # What the hexagon PROVIDES
│   │   └── output/                  # Driven ports (dependencies)
│   │       └── FlightRepository.java        # What the hexagon NEEDS
│   └── services/                    # Use case implementations (NO @Service!)
│       └── SearchFlightsService.java        # Pure Java - no Spring annotations
│
└── infrastructure/                   # OUTSIDE HEXAGON - Infrastructure layer
    ├── config/                      # Spring wiring
    │   └── ApplicationConfig.java   # @Configuration - wires hexagon at runtime
    ├── input/                       # Driving adapters (call the hexagon)
    │   └── rest/
    │       ├── FlightController.java        # @RestController - calls use case
    │       └── FlightResponse.java          # HTTP response DTO
    └── output/                      # Driven adapters (implement driven ports)
        └── persistence/
            ├── FlightEntity.java            # @Entity - JPA entity
            ├── JpaFlightRepository.java     # Spring Data JPA interface
            └── FlightRepositoryAdapter.java # @Component - implements FlightRepository
```

### Key Concepts (from Stack Overflow hexagonal architecture answer)

**1. Naming Confusion:**
- **Hexagonal Architecture** calls the inside part "the application"
- **DDD** has an "application layer" inside the hexagon
- In this project: Domain + Application = The Hexagon

**2. Ports & Adapters:**

**Driving Ports (Input Ports):**
- Interfaces defining what the hexagon OFFERS to the outside
- Location: `application/ports/input/`
- Example: `SearchFlightsUseCase` interface
- Implemented by: Use case classes in `application/services/`

**Driving Adapters (Input Adapters):**
- DON'T implement driving ports, they CALL them
- Location: `infrastructure/input/`
- Example: REST controller calls `SearchFlightsUseCase.searchByOrigin()`

**Driven Ports (Output Ports):**
- Interfaces defining what the hexagon NEEDS from the outside
- Location: `application/ports/output/`
- Example: `FlightRepository` interface
- Defined in terms of domain concepts, technology-agnostic

**Driven Adapters (Output Adapters):**
- DO implement driven ports
- Location: `infrastructure/output/`
- Example: `FlightRepositoryAdapter implements FlightRepository`

**3. Dependency Direction:**
```
Outside → Inside (allowed)
Infrastructure → Application/Domain (allowed)

Inside → Outside (FORBIDDEN at compile time)
Application/Domain → Infrastructure (FORBIDDEN)
```

**4. Configuration:**
- Use case implementations CANNOT have `@Service` (framework dependency!)
- Infrastructure layer wires everything at runtime
- `ApplicationConfig` with `@Bean` methods is how Spring creates and injects dependencies

### Architecture Principles:

1. **The hexagon is framework-agnostic**
   - Domain and application layers: Pure Java, NO Spring annotations
   - Can be tested without Spring
   - No compile-time dependency on infrastructure

2. **Ports define contracts**
   - Driving ports (input): What the hexagon provides to the outside
   - Driven ports (output): What the hexagon needs from the outside
   - Both are inside the hexagon (application layer)

3. **Infrastructure knows about the framework**
   - Driving adapters: REST controllers call use cases (with @RestController)
   - Driven adapters: JPA implementations implement ports (with @Component, @Entity)
   - Configuration: Wires everything together with @Configuration and @Bean

4. **Dependency injection happens at runtime**
   - Infrastructure layer injects driven adapters into use cases
   - This is where Spring comes in - but the hexagon doesn't know about Spring!

## Development Workflow

### Double-Loop TDD Practice
**ALWAYS follow this workflow when implementing new features:**

1. **Outer Loop - E2E Test (Red)**
   - Write a failing end-to-end test first
   - E2E test should spin up the full application using TestContainers
   - Make real HTTP calls to the application
   - Run: `./mvnw verify -Dtest=E2E*`

2. **Inner Loop - Unit Tests (Red-Green-Refactor)**
   - Write failing unit tests for the components needed
   - Implement the **simplest possible code** to make tests pass
   - **Including hardcoded return values** - this is intentional and correct
   - Run: `./mvnw test`
   - Refactor while keeping tests green
   - **IMPORTANT: Commit and push immediately when unit tests pass**

3. **Outer Loop - E2E Verification (Green)**
   - Return to E2E test and verify it passes
   - If it fails, add more unit tests and repeat inner loop
   - **Verify feature is truly complete** - ensure service uses repository, not hardcoded data
   - E2E test must seed real test data

4. **Commit and Push**
   - **Commit and push after each passing unit test**
   - **Commit and push when E2E tests pass**
   - Commit message should reflect the feature/behavior added
   - Use conventional commit format with detailed description

### Testing Commands

**Unit Tests Only (all tests except E2E):**
```bash
./mvnw test -Dtest="!E2E*"
```

**E2E Tests Only:**
```bash
./mvnw test -Dtest="E2E*"
```

**All Tests:**
```bash
./mvnw test
```

## Code Style

### Clean Code Principles (Bob Martin)
- **Single Responsibility Principle**: Each class should have one reason to change
- **Open/Closed Principle**: Open for extension, closed for modification
- **Dependency Inversion**: Depend on abstractions, not concretions
- **Small Functions**: Functions should be small and do one thing well
- **Meaningful Names**: Use intention-revealing names
- **Don't Repeat Yourself (DRY)**
- **Boy Scout Rule**: Leave code cleaner than you found it

### Java & Spring Boot Conventions
- Use dependency injection (constructor injection preferred)
- Use Lombok to reduce boilerplate (@Data, @Builder, @AllArgsConstructor, etc.)
- Follow standard Java naming conventions
- Use Optional for potentially null values
- Prefer composition over inheritance
- Use interfaces to define contracts (ports in hexagonal architecture)

### Hexagonal Architecture Guidelines
- **Domain layer (inside hexagon)**: Pure business entities, no framework dependencies
- **Application layer (inside hexagon)**: Ports (interfaces) and use case implementations (pure Java, NO @Service)
- **Infrastructure layer (outside hexagon)**: Framework-specific implementations (Spring config, REST, JPA)
- **Dependency rule**: Infrastructure depends on hexagon, hexagon NEVER depends on infrastructure
- **Configuration**: Use @Bean in infrastructure/config to wire use cases (NO @Service on use cases!)

## Testing Guidelines

### Unit Tests
- Test behavior, not implementation
- Use meaningful test method names (should/when pattern)
- Follow AAA pattern: Arrange, Act, Assert
- Mock external dependencies
- Keep tests fast and isolated
- **TDD: Write simplest code to pass, including hardcoded values**

### E2E Tests
- Use TestContainers to spin up real dependencies
- Make real HTTP calls using RestTemplate or WebTestClient
- Test complete user journeys
- Verify system behavior from outside
- Place in `src/test/java/.../e2e/` package

### Test Naming Conventions
**Unit Tests:**
- Naming: `ClassNameTest.java` (e.g., `SearchFlightsServiceTest.java`, `FlightControllerTest.java`)
- Location: `src/test/java/.../` (mirror main source structure)
- Run with: `./mvnw test -Dtest="!E2E*"`

**E2E Tests:**
- Naming: `E2EFeatureNameTest.java` (e.g., `E2EFlightSearchTest.java`)
- Location: `src/test/java/.../e2e/`
- Run with: `./mvnw test -Dtest="E2E*"`
- Must use `@SpringBootTest` with TestContainers

**Test Methods:**
- Format: `shouldDoSomething_whenCondition()`
- Alternative: `givenCondition_whenAction_thenResult()`
- Examples:
  - `shouldReturnFlightsFromOriginAirport()`
  - `shouldReturn404_whenOriginNotFound()`
  - `givenValidFlight_whenSaving_thenReturnsSavedFlight()`

## Running the Application
```bash
./mvnw spring-boot:run
```

## Building the Application
```bash
./mvnw clean package
```

## Database
- Using H2 in-memory database for development
- H2 Console can be enabled for debugging
- TestContainers for E2E tests with real database

## Git Workflow

### Commit Frequency
- **MUST commit and push after each passing unit test**
- **MUST commit and push when E2E tests pass**
- **MUST commit and push when feature is truly complete**
- Never commit failing tests
- Small, focused commits are better than large ones

### Commit Message Format
```
<type>: <short summary>

<detailed description of what was done and why>

TDD cycle: [Red/Green/Refactor stage]

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

### When to Commit
1. ✅ Unit tests passing (even with hardcoded implementation)
2. ✅ E2E tests passing
3. ✅ Feature complete and verified
4. ✅ Refactoring complete (tests still green)
5. ❌ Never commit broken/failing tests

### Push After Every Commit
- Always push immediately after committing
- Keep remote repository in sync
- Command: `git commit -m "..." && git push`

## Future Enhancements
- Add authentication/authorization
- Implement caching
- Add API documentation (Swagger/OpenAPI)
- Add logging and monitoring
- Implement pagination for search results
- Add comprehensive error handling and validation
